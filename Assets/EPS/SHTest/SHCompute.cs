using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SHCompute : MonoBehaviour
{

    //I actually have 0 idea what to do
    //however, I do know that I need a cube map of some sort.
    //I need to know how to create a cube map.(this specific line is generated by copilot)

    [SerializeField] private Texture2D cubeMap;
    [SerializeField] private Texture2D tex;
    [SerializeField] private MeshRenderer meshRenderer;

    //and I have the tool
    private Vector3 SampleSphere(){
        //this one is not uniform
        Vector3 direction = Random.onUnitSphere;
        //using the direction, compute theta and phi.
        return direction;
    }

    private Vector3 SampleHemisphere(Vector3 up){
        Vector3 direction = Random.onUnitSphere;
        if(Vector3.Dot(direction, up) < 0.0f){
            direction = -direction;
        }
        return direction;
    }

    public int Factorial(int f){
        //hopefully you never enter a negative number...
        if(f <= 0) return 1;
        return f * Factorial(f - 1);
    }

    
    public float GetK(int l, int m){
        int lmTop = Factorial(l - Mathf.Abs(m));
        float lmBottom = Factorial(l + Mathf.Abs(m));
        lmTop *= (2 * l + 1);
        lmBottom *= 4 * Mathf.PI;
        return Mathf.Sqrt(lmTop / lmBottom);
    }

    public void GetP(int l, int m){
        //if l == m, then we can just use the formula.
        //otherwise....
    }

    public void GetSHFunc(int l, int m){
        //|m| < l
        float sqrt2 = 1.4142135624f;
        if(m > 0){
            
        }
        else if(m < 0){
            //
        }
        else{
            //m == 0
            //K(l, 0) P(l, 0) cosTheta
        }
    }


    //eitherway, a lot of them are baked into the code
    //because no matter what happens, a good portion of the function doesn't change.

    [ContextMenu("SH9 Cubemap")]

    public async void SH9CubeMap(){
        //first, we need to find a way to bake all the results.
        //for each of the pixels..
        //generate N samples:
        int sampleCount = 100;
        float oneOverN = (1 / (float)sampleCount);
        Color[] coefficients = new Color[9]; //create a buffer for all the colors;
        for(int i = 0; i < sampleCount; i++){
            for(int j = 0; j < sampleCount; j++){
                //compute out the uv:
                float u = (i + Random.value) * oneOverN;
                float v = (j + Random.value) * oneOverN;

                //convert this to a direction, just like what we did before.
                float theta = Mathf.PI * 2 * (u - 0.5f);
                float phi = Mathf.PI * (v - 0.5f);

                //using these...
                float cosTheta = Mathf.Cos(theta);
                float sinTheta = Mathf.Sin(theta);

                float cosPhi = Mathf.Cos(phi);
                float sinPhi = Mathf.Sin(phi);

                Vector3 direction = new Vector3(
                    cosTheta * cosPhi,//for x, its cos theta
                    sinPhi,
                    sinTheta * cosPhi
                );

                //oh wow, we got all the information we need!
                //sample the cube map:
                Color c = SampleCubeMapAtUV(u, v);
                //dot this with the 9 basis to get a result...
                //first basis:
                coefficients[0] += 0.28209479f * c; //yup, because the first basis is constant.
                coefficients[1] += 0.48860251f * direction.y * c; //r is constant (1)
                coefficients[2] += 0.48860251f * direction.z * c;
                coefficients[3] += 0.48860251f * direction.x * c;

                //the basis are baked in here.
                //tex.SetPixel(Mathf.FloorToInt(u * tex.width), Mathf.FloorToInt(v * tex.height), c);
            }
        }
        float sampleRatio = 4.0f * Mathf.PI;
        sampleRatio /= (sampleCount * sampleCount);
        for(int i = 0; i < coefficients.Length; i++){
            coefficients[i] *= sampleRatio;
            Debug.Log(coefficients[i] * 255);
        }
    }

    //no idea what we are returning, don't worry yet.
    public void SH9Result(){
        //the result should be a color of some sort.
    }

    //This is 
    [ContextMenu("Brute Force CubeMap")]
    public void BruteForceCubeMap(){
        tex = new Texture2D(cubeMap.width, cubeMap.height, TextureFormat.ARGB32, false);
        //for each pixel up there, 
        for(int x = 0; x < tex.width; x++){
            for(int y = 0; y < tex.height; y++){
                //compute theta and phi from texture's uv coordinate:
                float theta = Mathf.PI * 2 * (x / (float)tex.width - 0.5f);
                float phi = Mathf.PI * ((y / (float)tex.height) - 0.5f);
                //convert this to a vector:
                float cosTheta = Mathf.Cos(theta);
                float sinTheta = Mathf.Sin(theta);

                float cosPhi = Mathf.Cos(phi);
                float sinPhi = Mathf.Sin(phi);

                Vector3 direction = new Vector3(
                    cosTheta * cosPhi,//for x, its cos theta
                    sinPhi,
                    sinTheta * cosPhi
                );

                Color c = SampleColorsOnCubemap(direction);
                //set the color to this average:
                tex.SetPixel(x, y, c);
            }
        }
        tex.Apply();
        if(meshRenderer){
            MaterialPropertyBlock mpb = new MaterialPropertyBlock();
            meshRenderer.GetPropertyBlock(mpb);
            mpb.SetTexture("_MainTex", tex);
            meshRenderer.SetPropertyBlock(mpb);
        }
    }

    public void OnDrawGizmosSelected(){
        Random.InitState(0);
        for(int i = 0; i < 25; i++){
            for(int j = 0; j < 25; j++){
                //compute out the uv:
                float u = (i + Random.value) * 0.04f;
                float v = (j + Random.value) * 0.04f;

                //convert this to a direction, just like what we did before.
                float theta = Mathf.PI * 2 * (u - 0.5f);
                float phi = Mathf.Acos(Mathf.Sqrt(1 - v));

                //using these...
                float cosTheta = Mathf.Cos(theta);
                float sinTheta = Mathf.Sin(theta);

                float cosPhi = Mathf.Cos(phi);
                float sinPhi = Mathf.Sin(phi);

                Vector3 direction = new Vector3(
                    cosTheta * cosPhi,//for x, its cos theta
                    sinPhi,
                    sinTheta * cosPhi
                );

                Debug.DrawLine(transform.position + direction * 0.99f, transform.position + direction);
            }
        }
    }

    public Vector2 DirToThetaPhi(Vector3 dir){
        float theta = Mathf.Atan2(dir.z, dir.x);
        float phi = Mathf.Asin(dir.y);
        return new Vector2(theta, phi);
    }

    public Vector2 ThetaPhiToUV(Vector2 tp){
        float u = tp.x; // this has a range of -pi to pi
        u = u / Mathf.PI; //this remaps to -1 to 1
        u = u * 0.5f + 0.5f; //and that maps back to 0 to 1.

        float v = tp.y;//this has a range of -pi/2 to pi/2 
        v = v / Mathf.PI;
        v += 0.5f; //remaps to 0 to 1

        return new Vector2(u, v);
    }

    public Vector2 DirToUV(Vector3 dir){
        float u = Mathf.Atan2(dir.z, dir.x); // this has a range of -pi to pi
        
        u = u / Mathf.PI; //this remaps to -1 to 1
        u = u * 0.5f + 0.5f; //and that maps back to 0 to 1.

        float v = Mathf.Asin(dir.y);//this has a range of -pi/2 to pi/2 
        v = v / Mathf.PI;
        v += 0.5f; //remaps to 0 to 1
        return new Vector2(u, v);
    }

    public Color SampleCubeMapAtUV(float u, float v){
        Color averageColor = new Color(0, 0, 0);
        //sample the texture
        averageColor = cubeMap.GetPixelBilinear(u, v);
        return averageColor;
    }

    //Just start with the dumbest of the dumbest method, and then we can be smart later on.
    public Color SampleColorsOnCubemap(Vector3 invec){
        Color averageColor = new Color(0, 0, 0);
        for(int i = 0; i < 1000; i++){
            Vector3 dir = SampleHemisphere(invec);
            Vector2 uv = DirToUV(dir);
            int x = Mathf.FloorToInt(uv.x * cubeMap.width);
            int y = Mathf.FloorToInt(uv.y * cubeMap.height);
            //sample the texture
            averageColor += cubeMap.GetPixel(x, y) * 0.001f;
        }
        return averageColor;
    }
}
