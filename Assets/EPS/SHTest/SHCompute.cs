using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SHCompute : MonoBehaviour
{

    //I actually have 0 idea what to do
    //however, I do know that I need a cube map of some sort.
    //I need to know how to create a cube map.(this specific line is generated by copilot)

    [SerializeField] private Texture2D cubeMap;
    [SerializeField] private Texture2D tex;
    [SerializeField] private MeshRenderer meshRenderer;

    private Color[] shCoefficients = new Color[9];

    //and I have the tool
    private Vector3 SampleSphere(){
        //this one is not uniform
        Vector3 direction = Random.onUnitSphere;
        //using the direction, compute theta and phi.
        return direction;
    }

    private Vector3 SampleHemisphere(Vector3 up){
        Vector3 direction = Random.onUnitSphere;
        if(Vector3.Dot(direction, up) < 0.0f){
            direction = -direction;
        }
        return direction;
    }

    public int Factorial(int f){
        //hopefully you never enter a negative number...
        if(f <= 0) return 1;
        return f * Factorial(f - 1);
    }

    
    public float GetK(int l, int m){
        int lmTop = Factorial(l - Mathf.Abs(m));
        float lmBottom = Factorial(l + Mathf.Abs(m));
        lmTop *= (2 * l + 1);
        lmBottom *= 4 * Mathf.PI;
        return Mathf.Sqrt(lmTop / lmBottom);
    }

    public void GetP(int l, int m){
        //if l == m, then we can just use the formula.
        //otherwise....
    }

    public void GetSHFunc(int l, int m){
        //|m| < l
        float sqrt2 = 1.4142135624f;
        if(m > 0){
            
        }
        else if(m < 0){
            //
        }
        else{
            //m == 0
            //K(l, 0) P(l, 0) cosTheta
        }
    }

    private void ClearData(){
        for(int i = 0; i < shCoefficients.Length; i++){
            shCoefficients[i] = new Color(0.0f, 0.0f, 0.0f, 0.0f);
        }
    }


    //eitherway, a lot of them are baked into the code
    //because no matter what happens, a good portion of the function doesn't change.

    [ContextMenu("SH9 Cubemap")]
    public void SH9CubeMap(){
        //first, we need to find a way to bake all the results.
        //for each of the pixels..
        ClearData();
        //generate N samples:
        int sampleCount = 250;
        float oneOverN = (1 / (float)sampleCount);
        for(int i = 0; i < sampleCount; i++){
            for(int j = 0; j < sampleCount; j++){
                //compute out the uv:
                float u = ((float)i + Random.value) * oneOverN;
                float v = ((float)j + Random.value) * oneOverN;

                //convert this to a direction, just like what we did before.
                float theta = 2 * Mathf.Acos(Mathf.Sqrt(1 - u));
                float phi = Mathf.PI * 2 * (v - 0.5f);

                //using these...
                float cosTheta = Mathf.Cos(theta);
                float sinTheta = Mathf.Sin(theta);

                float cosPhi = Mathf.Cos(phi);
                float sinPhi = Mathf.Sin(phi);

                Vector3 direction = new Vector3(
                    sinTheta * cosPhi,//cosTheta * cosPhi,//for x, its cos theta
                    sinTheta * sinPhi,
                    cosTheta
                );

                //oh wow, we got all the information we need!
                //sample the cube map:
                Color c = SampleCubeMapAtUV(u - 0.5f, v);
                float x = direction.x;
                float y = direction.y;
                float z = direction.z;
                float xSqr = x * x;
                float ySqr = y * y;
                float zSqr = z * z;

                //dot this with the 9 basis to get a result...
                //first basis:
                
                shCoefficients[0] += 0.28209479f * c; //yup, because the first basis is constant.
                shCoefficients[1] += 0.48860251f * y * c; //r is constant (1)
                shCoefficients[2] += 0.48860251f * z * c;
                shCoefficients[3] += 0.48860251f * x * c;
                shCoefficients[4] += 2.18509686f * 0.5f * x * y * c;
                shCoefficients[5] += 2.18509686f * 0.5f * y * z * c;
                shCoefficients[6] += 1.26156626f * 0.25f * (3 * zSqr - 1) * c;
                shCoefficients[7] += 2.18509686f * 0.5f * z * x * c;
                shCoefficients[8] += 2.18509686f * 0.25f * (xSqr - ySqr) * c;


                //the basis are baked in here.
                tex.SetPixel(Mathf.FloorToInt(u * tex.width), Mathf.FloorToInt(v * tex.height), c);
            }
        }
        tex.Apply();
        if(meshRenderer){
            MaterialPropertyBlock mpb = new MaterialPropertyBlock();
            meshRenderer.GetPropertyBlock(mpb);
            mpb.SetTexture("_MainTex", tex);
            meshRenderer.SetPropertyBlock(mpb);
        }

        float sampleRatio = 4.0f * Mathf.PI;
        sampleRatio /= (sampleCount * sampleCount);
        for(int i = 0; i < shCoefficients.Length; i++){
            shCoefficients[i] *= sampleRatio;
            Debug.Log(shCoefficients[i] * 255);
        }
        SH9Result();
    }

    //no idea what we are returning, don't worry yet.
    public void SH9Result(){
        List<Vector4> sh9Output = new List<Vector4>();
        for(int i = 0; i < shCoefficients.Length; i++){
            Color c = shCoefficients[i];
            if(i < sh9Output.Count){
                //if it's within range...
                sh9Output[i] = new Vector4(c.r, c.g, c.b, 1.0f);
            }
            else{
                sh9Output.Add(new Vector4(c.r, c.g, c.b, 1.0f));
            }
            
        }
        //the result should be a color of some sort.
        Shader.SetGlobalVectorArray("_SH9Vals", sh9Output);
    }

    //This is 
    //[ContextMenu("Brute Force CubeMap")]
    public void BruteForceCubeMap(){
        tex = new Texture2D(cubeMap.width, cubeMap.height, TextureFormat.ARGB32, false);
        //for each pixel up there, 
        for(int x = 0; x < tex.width; x++){
            for(int y = 0; y < tex.height; y++){
                //compute theta and phi from texture's uv coordinate:
                float theta = Mathf.PI * 2 * (x / (float)tex.width - 0.5f);
                float phi = Mathf.PI * ((y / (float)tex.height) - 0.5f);
                //convert this to a vector:
                float cosTheta = Mathf.Cos(theta);
                float sinTheta = Mathf.Sin(theta);

                float cosPhi = Mathf.Cos(phi);
                float sinPhi = Mathf.Sin(phi);

                Vector3 direction = new Vector3(
                    cosTheta * cosPhi,//for x, its cos theta
                    sinPhi,
                    sinTheta * cosPhi
                );

                Color c = SampleColorsOnCubemap(direction);
                //set the color to this average:
                tex.SetPixel(x, y, c);
            }
        }
        tex.Apply();
        if(meshRenderer){
            MaterialPropertyBlock mpb = new MaterialPropertyBlock();
            meshRenderer.GetPropertyBlock(mpb);
            mpb.SetTexture("_MainTex", tex);
            meshRenderer.SetPropertyBlock(mpb);
        }
    }
    /*
    [ContextMenu("Test Gizmo Result")]
    public void OnDrawGizmosSelected(){
        Random.InitState(0);
        for(int i = 0; i < 25; i++){
            for(int j = 0; j < 25; j++){
                //compute out the uv:
                float u = (i + Random.value) * 0.04f;
                float v = (j + Random.value) * 0.04f;

                //convert this to a direction, just like what we did before.
                float theta = 2 * Mathf.Acos(Mathf.Sqrt(1 - u));
                float phi = Mathf.PI * 2 * (v - 0.5f);
                //using these...
                float cosTheta = Mathf.Cos(theta);
                float sinTheta = Mathf.Sin(theta);

                float cosPhi = Mathf.Cos(phi);
                float sinPhi = Mathf.Sin(phi);

                Vector3 direction = new Vector3(
                    sinTheta * cosPhi,//cosTheta * cosPhi,//for x, its cos theta
                    sinTheta * sinPhi,
                    cosTheta
                );

                Debug.DrawLine(transform.position + direction * 0.99f, transform.position + direction);
            }
        }
    }*/

    public Vector2 DirToThetaPhi(Vector3 dir){
        float theta = Mathf.Atan2(dir.z, dir.x);
        float phi = Mathf.Asin(dir.y);
        return new Vector2(theta, phi);
    }

    public Vector2 ThetaPhiToUV(Vector2 tp){
        float u = tp.x; // this has a range of -pi to pi
        u = u / Mathf.PI; //this remaps to -1 to 1
        u = u * 0.5f + 0.5f; //and that maps back to 0 to 1.

        float v = tp.y;//this has a range of -pi/2 to pi/2 
        v = v / Mathf.PI;
        v += 0.5f; //remaps to 0 to 1

        return new Vector2(u, v);
    }

    public Vector2 DirToUV(Vector3 dir){
        float u = Mathf.Atan2(dir.z, dir.x); // this has a range of -pi to pi
        
        u = u / Mathf.PI; //this remaps to -1 to 1
        u = u * 0.5f + 0.5f; //and that maps back to 0 to 1.

        float v = Mathf.Asin(dir.y);//this has a range of -pi/2 to pi/2 
        v = v / Mathf.PI;
        v += 0.5f; //remaps to 0 to 1
        return new Vector2(u, v);
    }

    public Color SampleCubeMapAtUV(float u, float v){
        Color averageColor = new Color(0, 0, 0);
        //sample the texture
        averageColor = cubeMap.GetPixelBilinear(u, v);
        return averageColor;
    }

    //Just start with the dumbest of the dumbest method, and then we can be smart later on.
    public Color SampleColorsOnCubemap(Vector3 invec){
        Color averageColor = new Color(0, 0, 0);
        for(int i = 0; i < 1000; i++){
            Vector3 dir = SampleHemisphere(invec);
            Vector2 uv = DirToUV(dir);
            int x = Mathf.FloorToInt(uv.x * cubeMap.width);
            int y = Mathf.FloorToInt(uv.y * cubeMap.height);
            //sample the texture
            averageColor += cubeMap.GetPixel(x, y) * 0.001f;
        }
        return averageColor;
    }
}
