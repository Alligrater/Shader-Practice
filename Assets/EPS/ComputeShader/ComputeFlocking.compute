// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct BoidData{
    float3 position;
    float3 velocity;
    float4 individualData;
};

struct BoidOutputData {
    float3 position;
    float3 velocity;
    float3 param3;
};

///#1 - normal fish
///#2 - not so normal fish

static const float preyTable[] = {
    0, 1, 0, 1
};

RWStructuredBuffer<BoidData> _Boids;
RWStructuredBuffer<BoidOutputData> _Output;
//RWTexture2D<float4> Result;
float _TimeStep;
float _MaxSpeed;

//data from computeflocker.cs
float3 _SACWeight;
float3 _SACRange;
/*
float _SeparationWeight;
float _AlignmentWeight;
float _CohesionWeight;
float _SeparationRange;
float _AlignmentRange;
float _CohesionRange;*/

void Avoidance(uint id){
    //for each of the stuff in the boids.... find the nearest few?
}

float3 safeNormalize(float3 val){
    if(length(val) == 0){
        return val;
    }
    return normalize(val);
}

//make sure the speed doesn't go off the max speed
//this is broken as fuck
float3 ClampToMaxSpeed(float3 currentSpeed){
    //return currentSpeed;
    float speedMagnitude = length(currentSpeed);
    if(speedMagnitude == 0){
        return currentSpeed;
    }
    float3 speedNormalized = normalize(currentSpeed);
    if(speedMagnitude > _MaxSpeed){
        return speedNormalized * _MaxSpeed;
    }
    else{
        return currentSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    BoidData data = _Boids[id.x];

    //3 behaviors:
    //separation: avoid things that get too close
    //cohesion: try to move to the average position of the neighbours
    //alignment: try to have the average velocity of the neighbours

    //alignment
    float3 nearbyBoidVelocity = 0.0f;
    float alignmentCount = 0.0f;

    //cohesion
    float3 nearbyBoidPosition = 0.0f;
    float cohesionCount = 0.0f;

    //separation
    float3 nearbyBoidRepulsion = 0.0f;
    float separationCount = 0.0f;
    

    //we'll tackle separation first.
    for(uint i = 0; i < 1024; i++){
        //we'll just compute a falloff, based on the distance.
        if(i != id.x){
            //this is not triggered somehow...?
            //and yet why do you have knowledge of how many boids are nearby?
            
            BoidData queryBoid = _Boids[i];
            float3 boidDistanceVector = data.position - queryBoid.position; // gives off a vector to move away from.
            //nearbyBoidRepulsion += boidDistanceVector;

            //check if the vector is within range
            float distance = abs(length(boidDistanceVector));

            

            //data.color = data.color + (distance < _SACRange.x);
            if(distance > 0 && distance < _SACRange.x){
                nearbyBoidRepulsion += boidDistanceVector * _SACRange.x / (distance * distance);
                separationCount += 1.0f;
            }
            if(distance > 0 && distance < _SACRange.y){
                nearbyBoidVelocity += queryBoid.velocity;
                alignmentCount += 1.0f;
            }
            if(distance > 0 && distance < _SACRange.z){
                nearbyBoidPosition += queryBoid.position;
                cohesionCount += 1.0f;
            }
        }

    }

    //compute based on the weights the next velocity
    float3 newAcclr = 0.0f;
    float3 sepSum = 0, alignSum = 0, cohSum = 0;
    //avoid division by zero
    if(separationCount > 0.0f){
        //data.color = float3(1.0f, 0.0f, 0.0f);
        float3 steer = safeNormalize(nearbyBoidRepulsion) * _MaxSpeed - data.velocity;
        sepSum = ClampToMaxSpeed(steer);
        //newAcclr = _SACWeight.x * ClampToMaxSpeed(steer);
    }
    if(alignmentCount > 0.0f){
        //this one uses the sum of all velocities, and just normalize it and be done.
        float3 sumVec = safeNormalize(nearbyBoidVelocity) * _MaxSpeed;
        float3 steer = sumVec - data.velocity;
        alignSum = ClampToMaxSpeed(steer);
        //newAcclr += _SACWeight.y * ClampToMaxSpeed(steer);
    }
    if(cohesionCount > 0.0f){
        //only this one need to use the average position
        float3 sumVec = nearbyBoidPosition / cohesionCount - data.position;
        float3 steer = safeNormalize(sumVec) * _MaxSpeed - data.velocity;
        cohSum = ClampToMaxSpeed(steer);
        //newAcclr += _SACWeight.z * ClampToMaxSpeed(steer);
        //data.color = newAcclr;
    }

    newAcclr = sepSum * _SACWeight.x + alignSum * _SACWeight.y + cohSum * _SACWeight.z;
    newAcclr = ClampToMaxSpeed(newAcclr);
    
    data.velocity += newAcclr * _TimeStep;
    data.velocity = ClampToMaxSpeed(data.velocity);
    //data.color = (safeNormalize(data.velocity) + 1) * 0.5;

    //update the velocity based off the accleration
    //update the position first:
    data.position += data.velocity * _TimeStep;

    
    //wrap around when we go off the screen
    
    if(data.position.x > 72.0f){
        data.position.x = -72.0f;
    }
    if(data.position.x < -72.0f){
        data.position.x = 72.0f;
    }
    if(data.position.y > 72.0f){
        data.position.y = -72.0f;
    }
    if(data.position.y < -72.0f){
        data.position.y = 72.0f;
    }

    if(data.position.z > 72.0f){
        data.position.z = -72.0f;
    }
    if(data.position.z < -72.0f){
        data.position.z = 72.0f;
    }

    _Boids[id.x] = data;

    //_Boids[id.x] = data;
    _Output[id.x].position = data.position;
    _Output[id.x].velocity = safeNormalize(data.velocity);
    _Output[id.x].param3 = data.individualData.xyz;
    //_Boids[id.xy] 
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
