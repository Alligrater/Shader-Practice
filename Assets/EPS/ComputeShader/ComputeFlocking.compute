// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct BoidData{
    float3 position;
    float3 velocity;
    float3 color;
};

struct BoidOutputData {
    float3 position;
    float3 color;
};

RWStructuredBuffer<BoidData> _Boids;
RWStructuredBuffer<BoidOutputData> _Output;
//RWTexture2D<float4> Result;
float _TimeStep;
float _MaxSpeed;

//data from computeflocker.cs
float _SeparationWeight;
float _AlignmentWeight;
float _CohesionWeight;
float _SeparationRange;
float _AlignmentRange;
float _CohesionRange;

void Avoidance(uint id){
    //for each of the stuff in the boids.... find the nearest few?
}

//make sure the speed doesn't go off the max speed
float3 ClampToMaxSpeed(float3 currentSpeed){
    float3 speedNormalized = normalize(currentSpeed);
    float speedMagnitude = length(currentSpeed);
    if(speedMagnitude > _MaxSpeed){
        return speedNormalized * _MaxSpeed;
    }
    else{
        return currentSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    //Result[id.xy] = float4(id.x / 256.0f, id.y / 256.0f, 0.0f, 1.0f);
    BoidData data = _Boids[id.x];
    //uint newID = id.z * 64 + id.x;//id.z * 64 + id.y * 8 + id.x;
    //start position, keep as is for now.
    //data.position = float3(cos(id.x * 6.28f / 1024.0f), sin(id.x * 6.28f / 1024.0f), 0.0f);
    //data.velocity = float3(0.0f, 0.0f, 1.0f);
    //data.accleration = 0.0f;

    //3 behaviors:
    //separation: avoid things that get too close
    //cohesion: try to move to the average position of the neighbours
    //alignment: try to have the average velocity of the neighbours

    //alignment
    float nearbyBoidVelocity = 0.0f;
    float alignmentCount = 0.0f;

    //cohesion
    float nearbyBoidPosition = 0.0f;
    float cohesionCount = 0.0f;

    //separation
    float nearbyBoidRepulsion = 0.0f;
    float separationCount = 0.0f;
    

    //we'll tackle separation first.
    for(uint i = 0; i < 1024; i++){
        //we'll just compute a falloff, based on the distance.
        if(i == id.x) continue;
        BoidData queryBoid = _Boids[i];
        float3 boidDistanceVector = data.position - queryBoid.position; // gives off a vector to move away from.
        nearbyBoidRepulsion += boidDistanceVector;

        //check if the vector is within range
        float distance = length(boidDistanceVector);
        if(distance < _SeparationRange){
            nearbyBoidRepulsion += boidDistanceVector;
            separationCount += 1.0f;
        }
        if(distance < _AlignmentRange){
            nearbyBoidVelocity += queryBoid.velocity;
            alignmentCount += 1.0f;
        }
        if(distance < _CohesionRange){
            nearbyBoidPosition += queryBoid.position;
            cohesionCount += 1.0f;
        }
    }

    //compute based on the weights the next velocity
    float3 newVelocity = data.velocity;
    //avoid division by zero
    if(separationCount != 0.0f){
        newVelocity += _SeparationWeight * nearbyBoidRepulsion / separationCount;
    }
    if(alignmentCount != 0.0f){
        newVelocity += _AlignmentWeight * nearbyBoidVelocity / alignmentCount;
    }
    if(cohesionCount != 0.0f){
        newVelocity += _CohesionWeight * nearbyBoidPosition / cohesionCount;
    }
    data.velocity = ClampToMaxSpeed(newVelocity);


    //update the velocity based off the accleration
    //update the position first:
    data.position += data.velocity * _TimeStep * _MaxSpeed;
    _Boids[id.x] = data;

    //_Boids[id.x] = data;
    _Output[id.x].position = data.position;
    _Output[id.x].color = data.color;
    //_Boids[id.xy] 
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
