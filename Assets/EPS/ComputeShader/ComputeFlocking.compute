// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct BoidData{
    float3 accleration;
    float3 position;
    float3 velocity;
    float3 color;
};

struct BoidOutputData {
    float3 position;
    float3 color;
};

RWStructuredBuffer<BoidData> _Boids;
RWStructuredBuffer<BoidOutputData> _Output;
//RWTexture2D<float4> Result;
float _TimeStep;
float _MaxSpeed;

//data from computeflocker.cs
float _SeparationWeight;
float _AlignmentWeight;
float _CohesionWeight;
float _SeparationRange;
float _AlignmentRange;
float _CohesionRange;

void Avoidance(uint id){
    //for each of the stuff in the boids.... find the nearest few?
}

//make sure the speed doesn't go off the max speed
float3 ClampToMaxSpeed(float3 currentSpeed){
    float3 speedNormalized = normalize(currentSpeed);
    float speedMagnitude = length(currentSpeed);
    if(speedMagnitude > _MaxSpeed){
        return speedNormalized * _MaxSpeed;
    }
    else{
        return currentSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    //Result[id.xy] = float4(id.x / 256.0f, id.y / 256.0f, 0.0f, 1.0f);
    BoidData data = _Boids[id.x];
    //uint newID = id.z * 64 + id.x;//id.z * 64 + id.y * 8 + id.x;
    //start position, keep as is for now.
    //data.position = float3(cos(id.x * 6.28f / 1024.0f), sin(id.x * 6.28f / 1024.0f), 0.0f);
    //data.velocity = float3(0.0f, 0.0f, 1.0f);

    //3 behaviors:
    //separation: avoid things that get too close
    //cohesion: try to move to the average position of the neighbours
    //alignment: try to have the average velocity of the neighbours

    //alignment
    float nearbyBoidVelocity = 0.0f;
    float alignmentCount = 0.0f;

    //cohesion
    float nearbyBoidPosition = 0.0f;
    float cohesionCount = 0.0f;

    //separation
    float nearbyBoidRepulsion = 0.0f;
    float separationCount = 0.0f;
    

    //we'll tackle separation first.
    for(uint i = 0; i < 1024; i++){
        //we'll just compute a falloff, based on the distance.
        if(i != id.x){
            //this is not triggered somehow...?
            //and yet why do you have knowledge of how many boids are nearby?
            
            BoidData queryBoid = _Boids[i];
            float3 boidDistanceVector = data.position - queryBoid.position; // gives off a vector to move away from.
            nearbyBoidRepulsion += boidDistanceVector;

            //check if the vector is within range
            float distance = length(boidDistanceVector);
            
            if(distance < _SeparationRange){
                float pc = distance / _SeparationRange;    
                nearbyBoidRepulsion += boidDistanceVector * _SeparationRange / (distance * distance);
                separationCount += 1.0f;
            }
            if(distance < _AlignmentRange){
                nearbyBoidVelocity += queryBoid.velocity;
                alignmentCount += 1.0f;
            }
            if(distance < _CohesionRange){
                nearbyBoidPosition += queryBoid.position;
                cohesionCount += 1.0f;
            }
        }

    }

    //compute based on the weights the next velocity
    float3 newAcclr = 0.0f;
    //avoid division by zero
    if(separationCount > 0.0f){
        //data.color = float3(1.0f, 0.0f, 0.0f);
        float3 steer = nearbyBoidRepulsion - data.velocity;
        steer = normalize(steer);
        newAcclr += _SeparationWeight * steer;
        data.color = abs(newAcclr) / 32;
    }
    if(alignmentCount > 0.0f){
        //get average velocity
        float3 steer = nearbyBoidVelocity / alignmentCount - data.velocity;
        steer = normalize(steer);
        newAcclr += _AlignmentWeight * steer;
    }
    if(cohesionCount > 0.0f){
        float3 steer = nearbyBoidPosition / cohesionCount - data.position - data.velocity;
        steer = normalize(steer);
        newAcclr += _CohesionWeight * steer;
    }
    data.accleration += newAcclr;
    data.accleration = normalize(data.accleration);
    data.accleration *= _MaxSpeed;
    //data.accleration = lerp(data.accleration, newAcclr, 0.2f);
    data.velocity += data.accleration * _TimeStep;
    data.velocity = ClampToMaxSpeed(data.velocity);
    

    //update the velocity based off the accleration
    //update the position first:
    data.position += data.velocity * _TimeStep;

    
    //wrap around when we go off the screen
    if(data.position.x > 4.0f){
        data.position.x = -4.0f;
    }
    if(data.position.x < -4.0f){
        data.position.x = 4.0f;
    }
    if(data.position.y > 4.0f){
        data.position.y = -4.0f;
    }
    if(data.position.y < -4.0f){
        data.position.y = 4.0f;
    }
    if(data.position.z > 4.0f){
        data.position.z = -4.0f;
    }
    if(data.position.z < -4.0f){
        data.position.z = 4.0f;
    }


    //data.color = float3(alignmentCount, cohesionCount, separationCount) / 8;//length(data.accleration);//

    _Boids[id.x] = data;

    //_Boids[id.x] = data;
    _Output[id.x].position = data.position;
    _Output[id.x].color = data.color;
    //_Boids[id.xy] 
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
