// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct BoidData{
    float3 accleration;
    float3 position;
    float3 velocity;
    float3 color;
};

struct BoidOutputData {
    float3 position;
    float3 color;
};

RWStructuredBuffer<BoidData> _Boids;
RWStructuredBuffer<BoidOutputData> _Output;
//RWTexture2D<float4> Result;
float _TimeStep;
float _MaxSpeed;

//data from computeflocker.cs
float3 _SACWeight;
float3 _SACRange;
/*
float _SeparationWeight;
float _AlignmentWeight;
float _CohesionWeight;
float _SeparationRange;
float _AlignmentRange;
float _CohesionRange;*/

void Avoidance(uint id){
    //for each of the stuff in the boids.... find the nearest few?
}

float3 safeNormalize(float3 val){
    if(length(val) == 0){
        return val;
    }
    return normalize(val);
}

//make sure the speed doesn't go off the max speed
float3 ClampToMaxSpeed(float3 currentSpeed){
   
    float speedMagnitude = length(currentSpeed);
    if(speedMagnitude == 0){
        return currentSpeed;
    }
    float3 speedNormalized = normalize(currentSpeed);
    if(speedMagnitude > _MaxSpeed){
        return speedNormalized * _MaxSpeed;
    }
    else{
        return currentSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    BoidData data = _Boids[id.x];

    //3 behaviors:
    //separation: avoid things that get too close
    //cohesion: try to move to the average position of the neighbours
    //alignment: try to have the average velocity of the neighbours

    //alignment
    float nearbyBoidVelocity = 0.0f;
    float alignmentCount = 0.0f;

    //cohesion
    float nearbyBoidPosition = 0.0f;
    float cohesionCount = 0.0f;

    //separation
    float nearbyBoidRepulsion = 0.0f;
    float separationCount = 0.0f;
    

    //we'll tackle separation first.
    for(uint i = 0; i < 1024; i++){
        //we'll just compute a falloff, based on the distance.
        if(i != id.x){
            //this is not triggered somehow...?
            //and yet why do you have knowledge of how many boids are nearby?
            
            BoidData queryBoid = _Boids[i];
            float3 boidDistanceVector = data.position - queryBoid.position; // gives off a vector to move away from.
            //nearbyBoidRepulsion += boidDistanceVector;

            //check if the vector is within range
            float distance = length(boidDistanceVector);
            
            if(distance < _SACRange.x){
                nearbyBoidRepulsion += boidDistanceVector * _SACRange.x / (distance * distance);
                separationCount += 1.0f;
            }
            if(distance < _SACRange.y){
                nearbyBoidVelocity += queryBoid.velocity;
                alignmentCount += 1.0f;
            }
            if(distance < _SACRange.z){
                nearbyBoidPosition += queryBoid.position;
                cohesionCount += 1.0f;
            }
        }

    }

    //compute based on the weights the next velocity
    float3 newAcclr = 0.0f;
    //avoid division by zero
    if(separationCount > 0.0f){
        //data.color = float3(1.0f, 0.0f, 0.0f);
        float3 steer = safeNormalize(nearbyBoidRepulsion) * _MaxSpeed - data.velocity;
        newAcclr += _SACWeight.x * ClampToMaxSpeed(steer);
    }
    if(alignmentCount > 0.0f){
        //this one uses the sum of all velocities, and just normalize it and be done.
        float3 sumVec = safeNormalize(nearbyBoidVelocity) * _MaxSpeed;
        float3 steer = sumVec - data.velocity;
        newAcclr += _SACWeight.y * ClampToMaxSpeed(steer);
    }
    if(cohesionCount > 0.0f){
        //only this one need to use the average position
        float3 sumVec = nearbyBoidPosition / cohesionCount - data.position;
        float3 steer = safeNormalize(sumVec) * _MaxSpeed - data.velocity;
        newAcclr += _SACWeight.z * ClampToMaxSpeed(steer);
        //data.color = newAcclr;
    }
    //data.accleration += newAcclr;
    //data.accleration = normalize(data.accleration);
    //data.accleration *= _MaxSpeed;
    //data.accleration = lerp(data.accleration, newAcclr, 0.2f);
    //data.accleration += newAcclr;
    data.accleration = ClampToMaxSpeed(newAcclr);
    data.velocity += data.accleration * _TimeStep;
    data.velocity = ClampToMaxSpeed(data.velocity);
    

    //update the velocity based off the accleration
    //update the position first:
    data.position += data.velocity * _TimeStep;

    
    //wrap around when we go off the screen
    
    if(data.position.x > 16.0f){
        data.position.x = -16.0f;
    }
    if(data.position.x < -16.0f){
        data.position.x = 16.0f;
    }
    if(data.position.y > 16.0f){
        data.position.y = -16.0f;
    }
    if(data.position.y < -16.0f){
        data.position.y = 16.0f;
    }
    if(data.position.z > 16.0f){
        data.position.z = -16.0f;
    }
    if(data.position.z < -16.0f){
        data.position.z = 16.0f;
    }


    //data.color = float3(alignmentCount, cohesionCount, separationCount) / 8;//length(data.accleration);//

    _Boids[id.x] = data;

    //_Boids[id.x] = data;
    _Output[id.x].position = data.position;
    _Output[id.x].color = data.color;
    //_Boids[id.xy] 
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
